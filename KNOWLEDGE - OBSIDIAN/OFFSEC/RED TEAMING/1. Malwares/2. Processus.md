
https://learn.microsoft.com/fr-fr/windows/win32/procthread/creating-processes


Un programme est un ensemble d'instructions compilées dans un PE au format .exe ou .dll.

[[#Creation d'un processus]]
[[#Threads]]
[[#Mémoire]]
[[#Access Token]]
[[#Privileges]]
[[#Terminer un processus]]

# Creation d'un processus

Certaines API peuvent être utilisés pour créer un processus :
- [CreateProcessW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) -> Créer un processus avec le même Token que celui qui l'éxecute.
- [CreateProcessAsUserW](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasuserw) -> Créer un processus avec un Token définit.
- [CreateProcessWithLogonW](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithlogonw) -> Créer un processus avec les identifiants en clair.

Chaque API call la fonction Kernel **NtCreateUserProcess**.

![[Pasted image 20250909023042.png]]


# Threads

Un Thread est un type d'objet executé dans un processus permettant d'exécuter des sous processus en même temps. Il contient :
- L'état du CPU et ses registres
- La call stack (Pile d'execution) contenant les instructions CPU à éxecuter.

Fonctions pour créer des threads:
- [CreateThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) -> Créer un nouveau thread dans le même processus.
- [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) -> Créer un nouveau thread dans un processus distant.

Le pointeur de fonction agit comme le point d'entrée d'execution d'un nouveau Thread.

Ces 2 API call l'API [CreateRemoteThreadEx](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex) qui call ensuite la fonction Kernel **NtCreateRemoteThreadEx**.



# Mémoire

- Chaque processus est isolé sur le système (Il se croit seul)
- Il ne récupère pas d'espace mémoire physique directement
- Il est sandboxé dans un bloc de mémoire virtuelle contigu allouée (4Go pour les 32bits)
- Le kernel intervient pour faire l'intermédiaire entre les plages de mémoire vituelle et physique au travers d'une table de pagination


![[Table de pagination Processus.png]]

- Virtual APIs (API permettant d'allouer et libérer la mémoire virtuelle d'un processus )
	- [VirtualAlloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
	- [VirtualFree](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualfree)
	- [VirtualProtect](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)
- Heap APIs (Gestion du tas)
	- [HeapAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc)
	- [HeapReAlloc](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heaprealloc)
	- [HeapFree](https://learn.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapfree)
- Memory-mapping APIs (Permet la gestion des fichiers dans la mémoire depuis le disque)
	- [CreateFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga)
	- [OpenFileMappingA](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-openfilemappinga)
	- [MapViewOfFile](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile)


# Access Token

Lors de la création d'un processus, un Token d'accès (Primary Access Token) lui est attribué.

Celui-ci contient:

- SID du user
- SIDs des groupes auxquels le user appartient
- Ses privileges...
- ACL pour contrôler les accès

![[Pasted image 20250909031224.png]]



# Privileges

https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants

La fonction [AdjustTokenPrivileges](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges) permet d'activer un privilege.

```C++
BOOL AdjustTokenPrivileges(
 [in] HANDLE TokenHandle,
 [in] BOOL DisableAllPrivileges,
 [in, optional] PTOKEN_PRIVILEGES NewState,
 [in] DWORD BufferLength,
 [out, optional] PTOKEN_PRIVILEGES PreviousState,
 [out, optional] PDWORD ReturnLength 
);
```

Quelques privilèges dangereux :

- **SeDebugPrivilege** - obtain read/write handles to any process, even those owned by other users or SYSTEM.
    
- **SeTakeOwnershipPrivilege** - take ownership of any securable object including files, handles, and threads.
    
- **SeRestorePrivilege** - replace any file on the system. 
    
- **SeLoadDriverPrivilege** - load a device driver into the kernel.
    
- **SeCreateTokenPrivilege** - create arbitrary access tokens to impersonate any user with any privilege and any domain group membership.


# Terminer un processus

La fonction [ExitProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess) permet de au processus de se terminer de manière délicate.

La fonction [TerminateProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess) permet de terminer un autre processus de manière brutale.